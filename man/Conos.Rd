% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/conclass.R
\name{Conos}
\alias{Conos}
\title{Conos R6 class}
\description{
The class encompasses sample collections, providing methods for calculating and visualizing joint graph and communities.
}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{samples}}{list of samples (Pagoda2 or Seurat objects)}

\item{\code{pairs}}{pairwise alignment results}

\item{\code{graph}}{alignment graph}

\item{\code{clusters}}{list of clustering results named by clustering type}

\item{\code{expression.adj}}{adjusted expression values}

\item{\code{embedding}}{joint embedding}

\item{\code{n.cores}}{number of cores}

\item{\code{misc}}{list with unstractured additional info}

\item{\code{override.conos.plot.theme}}{}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{Conos$new()}}
\item \href{#method-addSamples}{\code{Conos$addSamples()}}
\item \href{#method-buildGraph}{\code{Conos$buildGraph()}}
\item \href{#method-getDifferentialGenes}{\code{Conos$getDifferentialGenes()}}
\item \href{#method-findCommunities}{\code{Conos$findCommunities()}}
\item \href{#method-plotPanel}{\code{Conos$plotPanel()}}
\item \href{#method-embedGraph}{\code{Conos$embedGraph()}}
\item \href{#method-plotClusterStability}{\code{Conos$plotClusterStability()}}
\item \href{#method-plotGraph}{\code{Conos$plotGraph()}}
\item \href{#method-correctGenes}{\code{Conos$correctGenes()}}
\item \href{#method-propagateLabels}{\code{Conos$propagateLabels()}}
\item \href{#method-getClusterCountMatrices}{\code{Conos$getClusterCountMatrices()}}
\item \href{#method-getDatasetPerCell}{\code{Conos$getDatasetPerCell()}}
\item \href{#method-getJointCountMatrix}{\code{Conos$getJointCountMatrix()}}
\item \href{#method-clone}{\code{Conos$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\if{latex}{\out{\hypertarget{method-new}{}}}
\subsection{Method \code{new()}}{
initialize Conos class
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Conos$new(
  x,
  ...,
  n.cores = parallel::detectCores(logical = FALSE),
  verbose = TRUE,
  override.conos.plot.theme = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{x}}{a named list of pagoda2 or Seurat objects (one per sample)}

\item{\code{n.cores}}{numeric Number of cores (default=parallel::detectCores(logical=FALSE))}

\item{\code{verbose}}{boolean Whether to provide verbose output (default=TRUE)}

\item{\code{override.conos.plot.theme}}{(default=FALSE)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
a new 'Conos' object
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-addSamples"></a>}}
\if{latex}{\out{\hypertarget{method-addSamples}{}}}
\subsection{Method \code{addSamples()}}{
initialize or add a set of samples to the conos panel. Note: this will simply add samples, but will not update graph, clustering, etc.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Conos$addSamples(x, replace = FALSE, verbose = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{x}}{a named list of pagoda2 or Seurat objects (one per sample)}

\item{\code{replace}}{boolean Whether the existing samples should be purged before adding new ones (default=FALSE)}

\item{\code{verbose}}{boolean Whether to provide verbose output (default=FALSE)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
invisible view of the full sample list
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-buildGraph"></a>}}
\if{latex}{\out{\hypertarget{method-buildGraph}{}}}
\subsection{Method \code{buildGraph()}}{
Build the joint graph that encompasses all the samples, establishing weighted inter-sample cell-to-cell links
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Conos$buildGraph(
  k = 15,
  k.self = 10,
  k.self.weight = 0.1,
  alignment.strength = NULL,
  space = "PCA",
  matching.method = "mNN",
  metric = "angular",
  k1 = k,
  data.type = "counts",
  l2.sigma = 1e+05,
  var.scale = TRUE,
  ncomps = 40,
  n.odgenes = 2000,
  matching.mask = NULL,
  exclude.samples = NULL,
  common.centering = TRUE,
  verbose = TRUE,
  base.groups = NULL,
  append.global.axes = TRUE,
  append.decoys = TRUE,
  decoy.threshold = 1,
  n.decoys = k * 2,
  score.component.variance = FALSE,
  snn = FALSE,
  snn.quantile = 0.9,
  min.snn.jaccard = 0,
  min.snn.weight = 0,
  snn.k = k.self,
  balance.edge.weights = FALSE,
  balancing.factor.per.cell = NULL,
  same.factor.downweight = 1,
  k.same.factor = k,
  balancing.factor.per.sample = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{k}}{integer (default=15)}

\item{\code{k.self}}{integer (default=10)}

\item{\code{k.self.weight}}{numeric (default=0.1)}

\item{\code{alignment.strength}}{(default=NULL)}

\item{\code{space}}{character (default='PCA')}

\item{\code{matching.method}}{character (default='mNN')}

\item{\code{metric}}{character (default='angular')}

\item{\code{k1}}{numeric (default=k)}

\item{\code{data.type}}{character (default='counts')}

\item{\code{l2.sigma}}{numeric (default=1e5)}

\item{\code{var.scale}}{boolean Whether to (default=TRUE)}

\item{\code{ncomps}}{integer (default=40)}

\item{\code{n.odgenes}}{integer (default=2000)}

\item{\code{matching.mask}}{(default=NULL)}

\item{\code{exclude.samples}}{(default=NULL)}

\item{\code{common.centering}}{boolean Whether to  (default=TRUE)}

\item{\code{verbose}}{boolean Whether to provide verbose output (default=TRUE)}

\item{\code{base.groups}}{(default=NULL)}

\item{\code{append.global.axes}}{boolean Whether to  (default=TRUE)}

\item{\code{append.decoys}}{boolean Whether to  (default=TRUE)}

\item{\code{decoy.threshold}}{integer (default=1)}

\item{\code{n.decoys}}{integer (default=k*2)}

\item{\code{score.component.variance}}{boolean Whether to  (default=FALSE)}

\item{\code{balance.edge.weights}}{boolean Whether to (default=FALSE)}

\item{\code{balancing.factor.per.cell}}{(default=NULL)}

\item{\code{same.factor.downweight}}{numeric (default=1.0)}

\item{\code{k.same.factor}}{integer (default=k)}

\item{\code{balancing.factor.per.sample}}{(default=NULL)}

\item{\code{neighborhood.average}}{boolean Whether to  (default=FALSE)}

\item{\code{neighborhood.average.k}}{integer (default=10)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
joint graph to be used for downstream analysis
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-getDifferentialGenes"></a>}}
\if{latex}{\out{\hypertarget{method-getDifferentialGenes}{}}}
\subsection{Method \code{getDifferentialGenes()}}{
Calculates differential genes. Estimates base mean, z-score, p-values, specificity, precision, expressionFraction, AUC (if append.auc=TRUE)
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Conos$getDifferentialGenes(
  clustering = NULL,
  groups = NULL,
  z.threshold = 3,
  upregulated.only = FALSE,
  verbose = TRUE,
  plot = FALSE,
  n.genes.to.show = 10,
  inner.clustering = FALSE,
  append.specificity.metrics = TRUE,
  append.auc = FALSE,
  n.cores = self$n.cores
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{clustering}}{name of the clustering to use}

\item{\code{groups}}{a factor on cells to use for coloring}

\item{\code{z.threshold}}{numeric Threshold for filtering z-scores (default=3.0). Above this value, z-scores are output.}

\item{\code{upregulated.only}}{boolean If FALSE, return the absolute value of z-scores (default=FALSE). Otherwise, return all z-scores.}

\item{\code{verbose}}{boolean Whether to provide verbose output (default=TRUE)}

\item{\code{n.genes.to.show}}{numeric (default=10)}

\item{\code{inner.clustering}}{(default=FALSE)}

\item{\code{append.specificity.metrics}}{boolean Whether to appeadn specificity metrics (default=TRUE)}

\item{\code{append.auc}}{boolean Whether to append AUC scores (default=FALSE)}

\item{\code{n.cores}}{numeric Number of cores (default=parallel::detectCores(logical=FALSE))}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
list of DE results
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-findCommunities"></a>}}
\if{latex}{\out{\hypertarget{method-findCommunities}{}}}
\subsection{Method \code{findCommunities()}}{
Find joint communities
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Conos$findCommunities(
  method = leiden.community,
  min.group.size = 0,
  name = NULL,
  test.stability = FALSE,
  stability.subsampling.fraction = 0.95,
  stability.subsamples = 100,
  verbose = TRUE,
  cls = NULL,
  sr = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{method}}{community detection method (igraph syntax) (default=leiden.community)}

\item{\code{min.group.size}}{numeric Minimal allowed community size (default=0)}

\item{\code{name}}{optional name of the clustering result (will default to the algorithm name) (default=NULL)}

\item{\code{verbose}}{boolean Whether to provide verbose output (default=TRUE)}

\item{\code{...}}{extra parameters are passed to the specified community detection method}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
invisible list containing identified communities (groups) and the full community detection result (result)
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-plotPanel"></a>}}
\if{latex}{\out{\hypertarget{method-plotPanel}{}}}
\subsection{Method \code{plotPanel()}}{
Plot panel of individual embeddings per sample with joint coloring
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Conos$plotPanel(
  clustering = NULL,
  groups = NULL,
  colors = NULL,
  gene = NULL,
  use.local.clusters = FALSE,
  plot.theme = NULL,
  use.common.embedding = FALSE,
  embedding.type = NULL,
  adj.list = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{clustering}}{name of the clustering to use}

\item{\code{groups}}{a factor on cells to use for coloring}

\item{\code{colors}}{a color factor (named with cell names) use for cell coloring}

\item{\code{gene}}{show expression of a gene}

\item{\code{use.common.embedding}}{boolean Whether to use the same embedding for each panel (default=FALSE)}

\item{\code{embedding.type}}{Embedding type, the parameter fed to plotSamples(embedding.type=embedding.type) (default=NULL). If use.common.embedding is TRUE, this parameter use the embedding in the conos object. (default=NULL)}

\item{\code{adj.list}}{adjacency list (default=NULL)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
ggplot2 object with the panel of plots
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-embedGraph"></a>}}
\if{latex}{\out{\hypertarget{method-embedGraph}{}}}
\subsection{Method \code{embedGraph()}}{
Generate an embedding of a joint graph
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Conos$embedGraph(
  method = "largeVis",
  M = 1,
  gamma = 1,
  alpha = 0.1,
  perplexity = NA,
  sgd_batches = 1e+08,
  seed = 1,
  target.dims = 2,
  verbose = TRUE,
  n.cores = self$n.cores,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{method}}{Embedding method (default='largeVis'). Currently 'largeVis' and 'UMAP' are supported}

\item{\code{M}}{numeric The number of negative edges to sample for each positive edge (default=1)}

\item{\code{gamma}}{numeric The strength of the force pushing non-neighbor nodes apart (default=1)}

\item{\code{alpha}}{numeric Hyperparameter used in the default distance function, \eqn{1 / (1 + \alpha \dot ||y_i - y_j||^2)} (default=0.1).  The function relates the distance
between points in the low-dimensional projection to the likelihood that the two points are nearest neighbors. Increasing \eqn{\alpha} tends
to push nodes and their neighbors closer together; decreasing \eqn{\alpha} produces a broader distribution. Setting \eqn{\alpha} to zero
enables the alternative distance function. \eqn{\alpha} below zero is meaningless.}

\item{\code{perplexity}}{The perplexity passed to largeVis (default=NA)}

\item{\code{sgd_batches}}{The number of edges to process during SGD (default=1e8). Defaults to a value set based on the size of the dataset. If the parameter given is
between \code{0} and \code{1}, the default value will be multiplied by the parameter.}

\item{\code{seed}}{numeric Random seed for the largeVis algorithm (default=1)}

\item{\code{target.dims}}{numeric Number of dimensions for the reduction (default=2). Higher dimensions can be used to generate embeddings for subsequent reductions by other methods, such as tSNE}

\item{\code{verbose}}{boolean Whether to provide verbose output (default=TRUE)}

\item{\code{n.cores}}{numeric Number of cores (default=parallel::detectCores(logical=FALSE))}

\item{\code{...}}{additional arguments, passed to UMAP embedding (run ?conos:::embedGraphUmap for more info)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
joint graph embedding
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-plotClusterStability"></a>}}
\if{latex}{\out{\hypertarget{method-plotClusterStability}{}}}
\subsection{Method \code{plotClusterStability()}}{
Plot cluster stability statistics.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Conos$plotClusterStability(clustering = NULL, what = "all")}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{clustering}}{string Name of the clustering result to show (default=NULL)}

\item{\code{what}}{string Show a specific plot (ari - adjusted rand index, fjc - flat Jaccard, hjc - hierarchical Jaccard, dend - cluster dendrogram) (default='all')}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
cluster stability statistics
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-plotGraph"></a>}}
\if{latex}{\out{\hypertarget{method-plotGraph}{}}}
\subsection{Method \code{plotGraph()}}{
Plot joint graph.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Conos$plotGraph(
  color.by = "cluster",
  clustering = NULL,
  groups = NULL,
  colors = NULL,
  gene = NULL,
  plot.theme = NULL,
  subset = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{color.by}}{character Users can either cluster by 'cluster' or by 'sample (default='cluster'). If any other string is input, an error is thrown.}

\item{\code{clustering}}{name of the clustering to use}

\item{\code{groups}}{a factor on cells to use for coloring}

\item{\code{colors}}{a color factor (named with cell names) use for cell coloring}

\item{\code{gene}}{show expression of a gene}

\item{\code{subset}}{a subset of cells to show (default=NULL)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
ggplot2 plot of joint graph
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-correctGenes"></a>}}
\if{latex}{\out{\hypertarget{method-correctGenes}{}}}
\subsection{Method \code{correctGenes()}}{
Smooth expression of genes, so they better represent structure of the graph.
  Use diffusion of expression on graph with the equation dv = exp(-a * (v + b))
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Conos$correctGenes(
  genes = NULL,
  n.od.genes = 500,
  fading = 10,
  fading.const = 0.5,
  max.iters = 15,
  tol = 0.005,
  name = "diffusion",
  verbose = TRUE,
  count.matrix = NULL,
  normalize = TRUE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{genes}}{List of genes for smoothing (default=NULL)}

\item{\code{n.od.genes}}{numeric If 'genes' is NULL, top n.od.genes of overdispersed genes are taken across all samples (default=500)}

\item{\code{fading}}{numeric Level of fading of expression change from distance on the graph (parameter 'a' of the equation) (default=10)}

\item{\code{fading.const}}{numeric Minimal penalty for each new edge during diffusion (parameter 'b' of the equation) (default=0.5)}

\item{\code{max.iters}}{numeric Maximal number of diffusion iterations (default=15)}

\item{\code{tol}}{numeric Tolerance after which the diffusion stops (default=5e-3)}

\item{\code{name}}{string Name to save the correction (default='diffusion')}

\item{\code{verbose}}{boolean Verbose mode (default=TRUE)}

\item{\code{count.matrix}}{Alternative gene count matrix to correct (rows: genes, columns: cells; has to be dense matrix). Default: joint count matrix for all datasets.}

\item{\code{normalize}}{boolean Whether to normalize values (default=TRUE)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
smoothed expression of the input genes
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-propagateLabels"></a>}}
\if{latex}{\out{\hypertarget{method-propagateLabels}{}}}
\subsection{Method \code{propagateLabels()}}{
Estimate labeling distribution for each vertex, based on provided labels.
There are two methods used for the propagation to calculate the distribution of labels: "solver" and "diffusion". 
* "diffusion" (default) will estimate the labeling distribution for each vertex, based on provided labels using a random walk.
* "solver" will propagate labels using the algorithm described by Zhu, Ghahramani, Lafferty (2003) <http://mlg.eng.cam.ac.uk/zoubin/papers/zgl.pdf>
Confidence values are then calculated by taking the maximum value from this distribution of labels, for each cell.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Conos$propagateLabels(labels, method = "diffusion", ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{method}}{type of propagation. Either 'diffusion' or 'solver'. 'solver' gives better result
but has bad asymptotics, so is inappropriate for datasets > 20k cells. (default='diffusion')}

\item{\code{...}}{additional arguments for conos:::propagateLabels* functions}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
list with three fields: 
* labels = matrix with distribution of label probabilities for each vertex by rows.
* uncertainty = 1 - confidence values 
* label.distribution = the distribution of labels calculated using either the methods "diffusion" or "solver"
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-getClusterCountMatrices"></a>}}
\if{latex}{\out{\hypertarget{method-getClusterCountMatrices}{}}}
\subsection{Method \code{getClusterCountMatrices()}}{
Estimate per-cluster molecule count matrix by summing up the molecules of each gene for all of the cells in each cluster.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Conos$getClusterCountMatrices(
  clustering = NULL,
  groups = NULL,
  common.genes = TRUE,
  omit.na.cells = TRUE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{clustering}}{name of the clustering to use}

\item{\code{groups}}{a factor on cells to use for coloring}

\item{\code{common.genes}}{boolean Whether to bring individual sample matrices to a common gene list (default=TRUE)}

\item{\code{omit.na.cells}}{boolean If set to FALSE, the resulting matrices will include a first column named 'NA' that will report total molecule counts for all of the cells that were not covered by the provided factor. (default=TRUE)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
a list of per-sample uniform dense matrices with rows being genes, and columns being clusters
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-getDatasetPerCell"></a>}}
\if{latex}{\out{\hypertarget{method-getDatasetPerCell}{}}}
\subsection{Method \code{getDatasetPerCell()}}{
applies 'getCellNames()' on all samples
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Conos$getDatasetPerCell()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
list of cellnames for all samples
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-getJointCountMatrix"></a>}}
\if{latex}{\out{\hypertarget{method-getJointCountMatrix}{}}}
\subsection{Method \code{getJointCountMatrix()}}{
something
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Conos$getJointCountMatrix(raw = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{raw}}{boolean If TRUE, return merged "raw" count matrices. Otherwise, return the merged count matrices. (default=FALSE)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
list of merged count matrices
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-clone"></a>}}
\if{latex}{\out{\hypertarget{method-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Conos$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
